""" Class Scenario

Creation date: 2018 11 05
Author(s): Erwin de Gelder

To do:
Move falls_into method to ScenarioCategory and rename it to "comprises".

Modifications:
2018 11 22: Make is possible to instantiate a Scenario from JSON code.
2018 12 06: Add functionality to return the derived Tags.
2018 12 06: Make it possible to return full JSON code (incl. attributes' JSON code).
2018 12 06: to_openscenario function added.
2018 12 07: fall_into method for checking if Scenario falls into ScenarioCategory.
2019 05 22: Make use of type_checking.py to shorten the initialization.
2019 10 13: Update of terminology.
2019 11 04: Add options to automatically assign unique ids to actor/activities.
2020 08 23: Remove the update_uid options, because uid is automatically generated by Thing.
2020 08 24: Make Scenario a subclass of TimeInterval.
2020 08 24: Enable instantiation of Scenario from json without needing full json code.
"""

from typing import Callable, List, Tuple
import fnmatch
import numpy as np
from .activity import Activity, activity_from_json
from .actor import Actor, actor_from_json
from .dynamic_physical_thing import DynamicPhysicalThing, dynamic_physical_thing_from_json
from .scenario_category import ScenarioCategory, derive_actor_tags, _check_match_matrix, \
    _check_acts, _print_tags, _get_acts
from .static_physical_thing import StaticPhysicalThing, static_physical_thing_from_json
from .time_interval import TimeInterval, _time_interval_props_from_json
from .type_checking import check_for_list, check_for_tuple


class Scenario(TimeInterval):
    """ Scenario - either a real-world scenario or a test case.

    A scenario is a quantitative description of the ego vehicle, its activities
    and/or goals, its dynamic environment (consisting of traffic environment and
    conditions) and its static environment. From the perspective of the ego
    vehicle, a scenario contains all relevant events.

    When instantiating the Scenario object, the name, start event, end event,
    unique id (uid), and tags are passed. To set the activities, actors, dynamic
    physical things, acts, and static physical things, use the corresponding
    methods, i.e., set_activities(), set_actors(),
    set_dynamic_physical_things(), set_acts(), and set_static_physical_things(),
    respectively.

    Attributes:
        static_physical_things (List[StaticPhysicalThings]): All the things that
            make up the static environment.
        dynamic_physical_things (List[DynamicPhysicalThing]): All dynamic
            physical things that are no actors.
        actors (List[Actor]): Actors that are participating in this scenario.
            This list should always include the ego vehicle.
        activities (List[Activity]): Activities that are relevant for this
            scenario.
        acts (List[tuple[DynamicPhysicalThing, Activity]]): The acts describe
            which actors perform which activities.
        name (str): A name that serves as a short description of the scenario.
        uid (int): A unique ID.
        tags (List[Tag]): A list of tags that formally defines the scenario
            category. These tags determine whether a scenario category comprises
            this scenario or not.
        start (Event): The starting event.
        end (Event): The end event.
    """

    def __init__(self, **kwargs):
        # Assign the attributes
        TimeInterval.__init__(self, **kwargs)
        self.static_physical_things = []   # Type: List[StaticPhysicalThing]
        self.dynamic_physical_things = []  # Type: List[DynamicPhysicalThing]
        self.actors = []                   # Type: List[Actor]
        self.activities = []               # Type: List[Activity]
        self.acts = []                     # Type: List[tuple(DynamicPhysicalThing, Activity)]

    def set_static_physical_things(self, static_physical_things: List[StaticPhysicalThing]) -> None:
        """ Set the static physical things.

        Check whether the static physical things are correctly defined.

        :param static_physical_things: List of static physical things that
            define the static environment.
        """
        # Check whether the static physical things are correctly defined.
        check_for_list("static_physical_things", static_physical_things, StaticPhysicalThing,
                       can_be_none=False)

        # Assign static physical things to an attribute.
        self.static_physical_things = static_physical_things

    def set_activities(self, activities: List[Activity]) -> None:
        """ Set the activities.

        Check whether the activities are correctly defined. Activities should be
        a list with instantiations of Activity.

        :param activities: List of activities that are used for this Scenario.
        """
        # Check whether the activities are correctly defined.
        check_for_list("activities", activities, Activity, can_be_none=False)

        # Assign actitivies to an attribute.
        self.activities = activities  # Type: List[Activity]

    def set_dynamic_physical_things(self, dynamic_physical_things: List[DynamicPhysicalThing]) \
            -> None:
        """ Set the dynamic physical things.

        Check whether the dynamic physical things are correctly defined. The
        dynamic physical things are physical things that have at least one state
        variable that changes while having no intent. For dynamic physical
        things with intent, see `set_actors()`.

        :param dynamic_physical_things: List of dynamic physical things.
        """
        # Check whether the static physical things are correctly defined.
        check_for_list("dynamic_physical_things", dynamic_physical_things, DynamicPhysicalThing,
                       can_be_none=False)

        # Assign static physical things to an attribute.
        self.dynamic_physical_things = dynamic_physical_things

    def set_actors(self, actors: List[Actor]) -> None:
        """ Set the actors.

        Check whether the actors are correctly defined. Actors should be a list
        with instantiations of Actor.

        :param actors: List of actors that participate in the Scenario.
        """
        # Check whether the actors are correctly defined.
        check_for_list("actors", actors, Actor, can_be_none=False)

        # Assign actors to an attribute.
        self.actors = actors  # Type: List[Actor]

    def set_acts(self, acts_scenario: List[Tuple[DynamicPhysicalThing, Activity]],
                 verbose: bool = True) -> None:
        """ Set the acts

        Check whether the acts are correctly defined. Each act should be a tuple
        with an actor, an activity, and a starting time, i.e., (Actor, Activity,
        float). Acts is a list containing multiple tuples (Actor, Activity,
        float).

        :param acts_scenario: The acts describe which actors perform which
            activities and a certain time. The actors and activities that are
            used in acts should also be passed with the actors and activities
            arguments. If not, a warning will be shown and the corresponding
            actor/activity will be added to the list of actors/activities.
        :param verbose: Set to False if warning should be surpressed.
        """
        check_for_list("acts", acts_scenario, tuple)
        for act in acts_scenario:
            check_for_tuple("act", act, (DynamicPhysicalThing, Activity))

        # Set the acts.
        self.acts = acts_scenario

        # Check whether the actors/activities defined with the acts are already listed. If not,
        # the corresponding actor/activity will be added and a warning will be shown.
        _check_acts(self.acts, self.dynamic_physical_things, self.actors, self.activities,
                    verbose=verbose)

    def derived_tags(self) -> dict:
        """ Return all tags, including the tags of the attributes.

        The Scenario has tags, but also its attributes can have tags. More
        specifically, the StaticEnvironmentCategory, each ActorCategory,
        and each ActivityCategory might have tags. A dictionary will be
        returned. Each item of the dictionary contains a list of tags
        corresponding to either the own object (i.e., ScenarioCategory), an
        ActorCategory, or the StaticEnvironment.

        The tags that might be associated with the ActivityCategory are returned
        with the ActorCategory if the corresponding ActorCategory is performing
        that ActivityCategory according to the defined acts.

        :return: List of tags.
        """
        # Instantiate the dictionary.
        tags = {}

        # Provide the tags of the very own object (Scenario).
        if self.tags:
            tags["{:s}::Scenario".format(self.name)] = self.tags

        # Provide the tags for each DynamicPhysicalThing.
        tags = derive_actor_tags(self.dynamic_physical_things, self.acts, tags=tags)

        # Provide the tags for each Actor.
        tags = derive_actor_tags(self.actors, self.acts, tags=tags)

        # Provide the tags for each StaticPhysicalThing.
        for static_physical_thing in self.static_physical_things:
            if static_physical_thing.get_tags():
                tags["{:s}::StaticPhysicalThing".format(static_physical_thing.name)] = \
                    static_physical_thing.get_tags()

        # Return the tags.
        return tags

    def print_tags(self) -> None:
        """ Print the derived tags. """
        print(_print_tags(self.derived_tags()))

    def falls_into(self, scenario_category: ScenarioCategory) -> bool:
        """ Determine whether the Scenario falls into the ScenarioCategory.

        It is checked whether the passed scenario category comprises this
        Scenario. To determine whether this is the case, only the derived tags
        are used. The derived tags from the ScenarioCategory should be at least
        be present (or subtags of the tags) in the Scenario.

        :param scenario_category: The potential ScenarioCategory it falls into.
        :return: Whether or not the ScenarioCategory comprises the Scenario.
        """
        # Determine the derived tags of the ScenarioCategory.
        sc_tags = scenario_category.derived_tags()  # sc = ScenarioCategory
        s_tags = self.derived_tags()                # s  = Scenario

        # Check for tags directly related to the ScenarioCategory. These tags should be directly
        # present for the scenario.
        if not self._check_tags(sc_tags, s_tags, "ScenarioCategory", "Scenario"):
            return False

        # Check for tags related to the StaticEnvironment.
        if not self._check_tags(sc_tags, s_tags, "StaticEnvironmentCategory", "StaticEnvironment"):
            return False

        # Check for the actors
        sc_actors = fnmatch.filter(sc_tags, "*::ActorCategory")
        s_actors = fnmatch.filter(s_tags, "*::Actor")
        if len(sc_actors) > len(s_actors):  # In this case, there are less actors in the Scenario.
            return False

        # Create a boolean matrix, where the (i,j)-th element is True if the i-th actor of the
        # ScenarioCategory (i.e., ActorCategory) might correspond to the j-th actor of the Scenario.
        match = np.zeros((len(sc_actors), len(s_actors)), dtype=np.bool)
        for i, sc_actor in enumerate(sc_actors):
            for j, s_actor in enumerate(s_actors):
                match[i, j] = (all(any(map(tag.is_supertag_of, s_tags[s_actor]))
                                   for tag in sc_tags[sc_actor]))

        return _check_match_matrix(match)

    @staticmethod
    def _check_tags(sc_tags: dict, s_tags: dict,
                    sc_class: str = "ScenarioCategory", s_class: str = "Scenario") -> bool:
        """ Check for tags of the ScenarioCategory in the Scenario.

        Check for the tags that are related to the ScenarioCategory's attribute
        specified my sc_class in the Scenario's attribute s_class. This can be
        for the ScenarioCategory itself (default, sc_class="ScenarioCategory"
        and s_class="Scenario") or the StaticEnvironment
        (sc_class="StaticEnvironmentCategory" and s_class="StaticEnvironment").

        :param sc_tags: Dictionary of the derived tags of the ScenarioCategory.
        :param s_tags: Dictionary of the derived tags of the Scenario.
        :param sc_class: Specify attribute to be used of the ScenarioCategory.
        :param s_class: Specify attribute to be used of the Scenario.
        :return: Whether the tags of the ScenarioCategory are found in the tags
            of the Scenario.
        """
        sc_keys = fnmatch.filter(sc_tags, "*::{:s}".format(sc_class))
        if sc_keys:  # In this case, there are tags directly related to the ScenarioCategory.
            s_keys = fnmatch.filter(s_tags, "*::{:s}".format(s_class))
            if s_keys:  # There are tags directly related to the Scenario.
                for tag in sc_tags[sc_keys[0]]:
                    if not any(map(tag.is_supertag_of, s_tags[s_keys[0]])):
                        return False  # A tag of the ScenarioCategory is not found in the Scenario.
            else:  # There are no tags at all directly related to the Scenario.
                return False
        return True

    def to_json(self) -> dict:
        scenario = TimeInterval.to_json(self)
        scenario["static_physical_thing"] = [dict(name=thing.name, uid=thing.uid)
                                             for thing in self.static_physical_things]
        scenario["dynamic_physical_thing"] = [dict(name=thing.name, uid=thing.uid)
                                              for thing in self.dynamic_physical_things]
        scenario["actor"] = [dict(name=actor.name, uid=actor.uid) for actor in self.actors]
        scenario["activity"] = [dict(name=activity.name, uid=activity.uid)
                                for activity in self.activities]
        scenario["act"] = []
        for dynamic_thing, activity in self.acts:
            key_name = "actor" if isinstance(dynamic_thing, Actor) else "dynamic_thing"
            scenario["act"].append({key_name: dynamic_thing.uid, "activity": activity.uid})
        scenario["derived_tags"] = self.derived_tags()
        for key, tags in scenario["derived_tags"].items():
            scenario["derived_tags"][key] = [tag.to_json() for tag in tags]
        return scenario

    def to_json_full(self) -> dict:
        scenario = self.to_json()
        scenario.update(TimeInterval.to_json_full(self))
        scenario["static_physical_thing"] = [thing.to_json_full()
                                             for thing in self.static_physical_things]
        scenario["dynamic_physical_thing"] = [thing.to_json_full()
                                              for thing in self.dynamic_physical_things]
        scenario["actor"] = [actor.to_json_full() for actor in self.actors]
        scenario["activity"] = [activity.to_json_full() for activity in self.activities]
        return scenario


def scenario_from_json(json: dict, **kwargs) -> Scenario:
    """ Get Scenario object from JSON code

    It is assumed that all the attributes are fully defined. Alternatively,
    the attributes can be passed via optional arguments. The following optional
    arguments are allowed:
    - start: The start event.
    - end: The end event.
    - static_physical_things: The static physical things that define the static
        environment.
    - dynamic_physical_things: The dynamic physical things that do not have an
        intent.
    - actors: The dynamic physical things that do have an intent.
    - activities: The activities that describe the evolution of the dynamic
        environment.

    :param json: JSON code of Scenario.
    :return: Scenario object.
    """
    objects = dict(start=None,
                   end=None,
                   static_physical_things=None,
                   dynamic_physical_things=None,
                   actors=None,
                   activities=None)
    objects.update(kwargs)
    scenario = Scenario(**_time_interval_props_from_json(json, start=objects["start"],
                                                         end=objects["end"]))

    # The static physical things.
    if objects["static_physical_things"] is None:
        objects["static_physical_things"] = _create_scenario_attributes(
            json, "static_physical_thing", static_physical_thing_from_json)
    scenario.set_static_physical_things(objects["static_physical_things"])

    # The dynamic physical things.
    if objects["dynamic_physical_things"] is None:
        objects["dynamic_physical_things"] = _create_scenario_attributes(
            json, "dynamic_physical_thing", dynamic_physical_thing_from_json)
    scenario.set_dynamic_physical_things(objects["dynamic_physical_things"])

    # The actors.
    if objects["actors"] is None:
        objects["actors"] = _create_scenario_attributes(json, "actor", actor_from_json)
    scenario.set_actors(objects["actors"])

    # The activities.
    if objects["activities"] is None:
        objects["activities"] = _create_scenario_attributes(json, "activity", activity_from_json)
    scenario.set_activities(objects["activities"])

    # Create the acts.
    scenario.set_acts(_get_acts(json, objects["dynamic_physical_things"], objects["actors"],
                                objects["activities"]))

    # We are done, so we can return the scenario.
    return scenario


def _create_scenario_attributes(json: dict, class_name: str, func_from_json: Callable) -> List:
    """ Create list of objects of the class `class_name`.

    :param json: The dictionary with the JSON code.
    :param class_name: The name of the class for which the objects are to be
        instantiated.
    :param func_from_json: Function to instantiate an object.
    :return: List of objects that are member of the class `class_name`.
    """
    # Create the actor categories (ActorCategory) and actors (Actor).
    categories = []
    categories_ids = []
    objects = []
    for json_object in json[class_name]:
        if json_object["category"]["id"] in categories_ids:
            # Category object is already defined.
            category = categories[categories_ids.index(json_object["category"]["id"])]
            objects.append(func_from_json(json_object, category=category))
        else:
            objects.append(func_from_json(json_object))
            categories.append(objects[-1].category)
            categories_ids.append(categories[-1].uid)
    return objects
