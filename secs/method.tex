\section{\acl{ourmetric}}
\label{sec:method}

In this section, we propose \cstarta\ac{ourmetric}: \cenda a method for deriving a metric that quantifies the risk of a certain event, such as a collision, in a particular situation in which a vehicle - hereafter, the \textit{ego vehicle} - is in and that is applicable for real-time use.
\cstarta The \ac{ourmetric} \cenda consists of four steps. 
The first step is the parameterization of the current situation and the possible future situations.
Second, based on the current situation, we estimate the probability (density) for the possible future situations. 
The third step includes determining the probability of the specified event based on the current and the future situations.
Finally, local regression is used to speed up the calculations and to make it possible to use the \ac{ssm} in real time. 
These four steps are described in the following subsections.

In the remainder of this article, the following notation is used. 
To denote a probability, $\probability{\cdot}$ is used. 
\Iac{pdf} is denoted by $\density{\cdot}$. 
The conditional probability $\probabilitycond{\dummyvara}{\dummyvarb}$ is verbalized as \textit{the probability of $\dummyvara$ given $\dummyvarb$}. 
Similarly, the conditional \ac{pdf} is denoted by $\densitycond{\cdot}{\cdot}$. 
To denote the estimation of any of the aforementioned quantities, a circumflex is used, e.g, $\probabilityest{\dummyvara}$ denotes the estimated probability of $\dummyvara$.



\subsection{Parameterize current and future situations}
\label{sec:parametrization}

The first step is to parameterize the current situation the ego vehicle is in. 
In other words, the current situation needs to be described using $\situationcurrentdim$ numbers that are stacked into one vector $\situationcurrent \in \situationcurrentspace \subseteq \realnumbers^{\situationcurrentdim}$. 
As an example, $\situationcurrent$ could contain the speed of the ego vehicle and the distance toward its preceding vehicle. 
In \cref{sec:case study}, we will consider more examples.

Next to describing the current situation, the future situation is described using $\situationfuturedim$ numbers stacked into one vector $\situationfuture \in \situationfuturespace \subseteq \realnumbers^{\situationfuturedim}$. 
Together with $\situationcurrent$, $\situationfuture$ contains enough information to describe how the relevant future, e.g., the next 5 seconds, around the ego vehicle develops over time. 
As an example, $\situationfuture$ could contain the speed for the next 5 seconds of the leading vehicle (if any) that is in front of the ego vehicle.

Let $\collision$ denote an event, e.g., a collision, such that the probability of this event is $\probability{\collision}$.
The goal of our \ac{ssm} is to estimate the probability of the event $\collision$ given a particular situation $\situationcurrent$, i.e., $\probabilitycond{\collision}{\situationcurrent}$.
We do this by considering all future situations, $\situationfuturespace$, and calculating the probability of a collision given each possible value of $\situationfuture$. 
Using integration, we obtain $\probabilitycond{\collision}{\situationcurrent}$:
\begin{equation}
	\label{eq:probability collision expectation}
	\probabilitycond{\collision}{\situationcurrent} 
	= \int_{\situationfuturespace} 
	\probabilitycond{\collision}{\situationcurrent, \situationfuture} 
	\densitycond{\situationfuture}{\situationcurrent} 
	\ud \situationfuture.
\end{equation}
%In \cref{sec:estimate future}, we propose a method to estimate $\densitycond{\situationfuture}{\situationcurrent}$ and in \cref{sec:estimate collision}, we propose a method to estimate $\probabilitycond{\collision}{\situationcurrent, \situationfuture}$.



\subsection{Estimate $\densitycond{\situationfuture}{\situationcurrent}$}
\label{sec:estimate future}

In this section, we propose a method to estimate $\densitycond{\situationfuture}{\situationcurrent}$, i.e., the \ac{pdf} of $\situationfuture$ given $\situationcurrent$.
Using the product rule for probability, we can write:
\begin{equation}
	\densitycond{\situationfuture}{\situationcurrent} 
	= \frac{\density{\situationcurrent, \situationfuture}}{\density{\situationcurrent}}
	= \frac{\density{\situationcurrent, \situationfuture}}{
		\int_{\situationfuturespace} \density{\situationcurrent, \situationfuture} \ud\situationfuture
	}.
\end{equation}
Thus, it suffices to estimate $\density{\situationcurrent, \situationfuture}$. 

Our proposal is to estimate $\density{\situationcurrent, \situationfuture}$ in a data-driven manner. 
A data-driven approach brings several benefits.
First, the estimate automatically adapts to local driving styles and behaviors, which can change from region to region, provided that the data are obtained from the same local traffic.
Second, assumptions such as a constant speed of other vehicles, are not needed.
For our data-driven approach, let us assume that we have obtained $\situationnumberof$ situations, denoted by $\situationcurrentinstance{\situationindex}\in\situationcurrentspace, \situationindex\in\{1,\ldots,\situationnumberof\}$, and their corresponding future situations described by $\situationfutureinstance{\situationindex}\in\situationfuturespace$.



\subsubsection{Special case: all parameters from one distribution}
\label{sec:one kde}

We first explain how to estimate $\density{\situationcurrent, \situationfuture}$ if we assume that all parameters depend on each other and that no further simplifications are possible. 
The shape of the \ac{pdf} $\density{\situationcurrent, \situationfuture}$ is unknown beforehand. 
Furthermore, the shape of the estimated \ac{pdf} might change as more data are acquired. 
Assuming a functional form of the \ac{pdf} and fitting the parameters of the \ac{pdf} to the data may therefore lead to inaccurate fits unless a lot of hand-tuning is applied.
We employ a non-parametric approach using \ac{kde} \autocite{rosenblatt1956remarks, parzen1962estimation} because the shape of the \ac{pdf} is then automatically computed and \ac{kde} is highly flexible regarding the shape of the \ac{pdf}. 
Using the \ac{kde}, the estimated \ac{pdf} becomes:
\begin{equation}
	\label{eq:kde estimate}
	\densityest{\situationcurrent,\situationfuture}
	= \frac{1}{\situationnumberof} \sum_{\situationindex=1}^{\situationnumberof}
	\kernelfuncnormalized{\bandwidthmatrix}{
		\begin{bmatrix}
			\situationcurrent \\
			\situationfuture
		\end{bmatrix} -
		\begin{bmatrix}
			\situationcurrentinstance{\situationindex} \\
			\situationfutureinstance{\situationindex}
		\end{bmatrix}
	},
\end{equation}
where $\kernelfuncnormalized{\bandwidthmatrix}{\cdot}$ is an appropriate kernel function with positive definite bandwidth matrix $\bandwidthmatrix$. 
The choice of the kernel $\kernelfuncnormalized{\bandwidthmatrix}{\cdot}$ is not as important as the choice of the bandwidth matrix $\bandwidthmatrix$ \autocite{turlach1993bandwidthselection}.
For example, the Gaussian kernel is given by \autocite{duong2007ks}
\begin{equation}
	\label{eq:kernel current future}
	\kernelfuncnormalized{\bandwidthmatrix}{\dummyvarkernel}
	= \frac{1}{\left( 2 \pi \right)^{\left( \situationcurrentdim + \situationfuturedim \right) / 2} 
	\left|\bandwidthmatrix\right|^{1/2} }
	\e{ -\frac{1}{2} \dummyvarkernel\transpose \bandwidthmatrix^{-1} \dummyvarkernel }.
\end{equation}

The bandwidth matrix $\bandwidthmatrix$ controls the width of the kernel, or, in other words, the influence of each sampling point on nearby regions. 
There are many different ways of estimating the bandwidth, ranging from simple reference rules like, e.g., Silverman's rule of thumb \autocite{silverman1986density} to more elaborate methods; see \autocite{turlach1993bandwidthselection, chiu1996comparative, jones1996brief, bashtannyk2001bandwidth, zambom2013review} for reviews of different bandwidth selection methods.
Here, we use one-leave-out cross-validation to compute the bandwidth because this minimizes the Kullback-Leibler divergence between the real \ac{pdf} $\density{\situationcurrent, \situationfuture}$ and the estimated \ac{pdf} $\densityest{\situationcurrent, \situationfuture}$ \autocite{turlach1993bandwidthselection, zambom2013review}.

Drawing samples from the \ac{kde} in \cref{eq:kde estimate} is straightforward: two random numbers are drawn, one to choose a random generator kernel out of the $\situationnumberof$ kernels that are used to construct the \ac{kde}, and one random number from that kernel.
Sampling from $\densityestcond{\situationfuture}{\situationcurrent}$ works similarly, but instead of using an equal probability for each random generator kernel to be selected, different probabilities are used based on $\situationcurrent$.
For more information on sampling from a conditional \ac{pdf} obtained using \ac{kde}, see \autocite{holmes2012fast, degelder2021conditional}.



\subsubsection{Not all parameters from one distribution}
\label{sec:no special case}

Due to the curse of dimensionality \autocite{scott2015multivariate}, estimating $\density{\situationcurrent, \situationfuture}$ with one \ac{kde} according to \cref{eq:kde estimate} becomes inaccurate if $\situationcurrentdim + \situationfuturedim$ becomes large.
There are a few ways to avoid this curse of dimensionality.
Without going into much detail, we list a few options.

One option is to assume that one or more parameters are independent of the other parameters. 
E.g., suppose that $\situationfuture=\begin{bmatrix}\situationfutureparta & \situationfuturepartb\end{bmatrix}\transpose$, such that $\situationfuturepartb$ is independent of $\situationcurrent$ and $\situationfutureparta$.
Then we can write
\begin{equation}
	\density{\situationcurrent, \situationfuture}
	= \density{\situationcurrent, \situationfutureparta, \situationfuturepartb}
	= \density{\situationcurrent, \situationfutureparta} \cdot \density{\situationfuturepartb}.
\end{equation}
In this case, we would need to estimate $\density{\situationcurrent, \situationfutureparta}$ and $\density{\situationfuturepartb}$, which can be done in a similar manner as presented in \cref{sec:one kde}.
Because these two \acp{pdf} have less variables than $\density{\situationcurrent, \situationfuture}$, the two estimated \acp{pdf} will suffer less from the curse of dimensionality \autocite{scott2015multivariate}.

Another option is to model $\densitycond{\situationfuture}{\situationcurrent}$ as a cascade of conditional probabilities. 
For example, using the partitioning $\situationfuture=\begin{bmatrix}\situationfutureparta & \situationfuturepartb\end{bmatrix}\transpose$, $\densitycond{\situationcurrent}{\situationfuture}$ can be approximated using two conditional densities:
\begin{equation}
	\densitycond{\situationfuture}{\situationcurrent}
	= \densitycond{\situationfutureparta, \situationfuturepartb}{\situationcurrent}
	= \densitycond{\situationfutureparta}{\situationfuturepartb, \situationcurrent} \cdot \densitycond{\situationfuturepartb}{\situationcurrent}
	\approx \densitycond{\situationfutureparta}{\situationfuturepartb} \cdot \densitycond{\situationfuturepartb}{\situationcurrent}.
\end{equation}
The same partitioning can be applied to $\densitycond{\situationfutureparta}{\situationfuturepartb}$ and $\densitycond{\situationfuturepartb}{\situationcurrent}$ until only two-dimensional \acp{pdf} need to be estimated.
\cstarta Although this will lead to larger approximation errors, the lower-dimensional \acp{pdf} can be better estimated. \cenda
For more information on this approach, we refer the reader to \autocite{aas2009paircopula, nagler2016evading}.



\subsubsection{Reduce number of parameters using \acl{svd}}
\label{sec:parameter reduction}

One way to avoid the curse of dimensionality is to use \iac{svd} \autocite{golub2013matrix} to reduce the number of parameters.
With \iac{svd}, the parameters $\situationcurrent$ and $\situationfuture$ are transformed into a lower-dimensional vector of parameters in such a way that the reduced vector of parameters describes as much of the variation as possible.
To do this, \iac{svd} is made of the matrix that contains all $\situationnumberof$ observed situations:
\begin{equation}
	\begin{bmatrix}
		\situationcurrentinstance{1}-\situationcurrentmean & \cdots & \situationcurrentinstance{\situationnumberof}-\situationcurrentmean \\
		\situationfutureinstance{1}-\situationfuturemean & \cdots & \situationfutureinstance{\situationnumberof}-\situationfuturemean
	\end{bmatrix} = \svdu \svds \svdv\transpose.
\end{equation}
Here, $\situationcurrentmean=\sum_{\situationindex=1}^{\situationnumberof}\situationcurrentinstance{\situationindex}$ and $\situationfuturemean=\sum_{\situationindex=1}^{\situationnumberof}\situationfutureinstance{\situationindex}$.
The matrices $\svdu \in \realnumbers^{\left(\situationcurrentdim+\situationfuturedim\right)\times\left(\situationcurrentdim+\situationfuturedim\right)}$ and $\svdv \in \realnumbers^{\situationnumberof \times \situationnumberof}$ are orthonormal, i.e., $\svdu^{-1}=\svdu\transpose$ and $\svdv^{-1}=\svdv\transpose$.
Moreover, $\svds\in\realnumbers^{\left(\situationcurrentdim+\situationfuturedim\right)\times\situationnumberof}$ has only zeros except at the diagonal: the $(\svdindex,\svdindex)$-th element is $\svdsv{\svdindex}$, $\svdindex\in\{1,\ldots,\svdrank\}$ with  $\svdrank=\min(\situationcurrentdim+\situationfuturedim, \situationnumberof)$, such that
\begin{equation}
	\svdsv{1} \geq \svdsv{2} \geq \ldots \geq \svdsv{\svdrank} \geq 0.
\end{equation}
Because these so-called singular values are in decreasing order, we can approximate $\situationcurrent$ and $\situationfuture$ by setting $\svdsv{\svdindex}=0$ for $\svdindex > \dimension$ with $\situationcurrentdim < \dimension < \situationcurrentdim+\situationfuturedim$:
\begin{equation}
	\label{eq:svd approximation}
	\begin{bmatrix}
		\situationcurrentinstance{\situationindex} - \situationcurrentmean \\
		\situationfutureinstance{\situationindex} - \situationfuturemean
	\end{bmatrix}
	= \sum_{\svdindex=1}^{\svdrank} \svdsv{\svdindex} \svdventry{\situationindex}{\svdindex} \svduvec{\svdindex}
	\approx \sum_{\svdindex=1}^{\dimension} \svdsv{\svdindex} \svdventry{\situationindex}{\svdindex} \svduvec{\svdindex},
	= \begin{bmatrix} \svduupperleft \\ \svdulowerleft \end{bmatrix} \svdsupperleft \svdvvecd{\situationindex},
\end{equation}
where $\svdventry{\situationindex}{\svdindex}$ is the $(\situationindex,\svdindex)$-th element of $\svdv$ and $\svduvec{\svdindex}$ is the $\svdindex$-th column of $\svdu$.
Moreover, $\svduupperleft$ is the $\situationcurrentdim$-by-$\dimension$ upper left submatrix of $\svdu$, $\svdulowerleft$ is the $\situationfuturedim$-by-$\dimension$ lower left submatrix $\svdu$, $\svdsupperleft\in\realnumbers^{\dimension\times\dimension}$ is the diagonal matrix with the first $\dimension$ singular values on its diagonal and $\svdvvecd{\situationindex}\transpose = \begin{bmatrix} \svdventry{\situationindex}{1} & \cdots & \svdventry{\situationindex}{\dimension}	\end{bmatrix}$.

We can estimate the probability density of $\svdvvecd{\situationindex}$ in a similar way as described in \cref{sec:one kde}.
To sample from $\densityestcond{\situationfuture}{\situationcurrent}$, we can sample from the estimated distribution of $\svdvvecd{\situationindex}$.
Because \cref{eq:svd approximation} is a linear mapping, the sample $\svdvvecsymbol$ that is drawn from the estimated distribution of $\svdvvecd{\situationindex}$ is subject to a linear constraint:
\begin{equation}
	\label{eq:linear constraint}
	\svduupperleft \svdsupperleft \svdvvecsymbol = \situationcurrent - \situationcurrentmean.
\end{equation}
In \autocite{degelder2021conditional}, an algorithm is provided for sampling from \iac{kde} with a Gaussian kernel of \cref{eq:kernel current future} such that the resulting samples are subject to a linear constraint like \cref{eq:linear constraint}.



\subsection{Estimate $\probabilitycond{\collision}{\situationcurrent}$ using a Monte Carlo simulation}
\label{sec:estimate collision}

\cstarta Monte Carlo simulations are used to estimate $\probabilitycond{\collision}{\situationcurrent}$, i.e., the probability of an event $\collision$ given the current situation $\situationcurrent$. \cenda
The details of the simulation depends on the actual application. 
For example, if the goal of our \ac{ssm} is to evaluate the risk that a human-driven vehicle collides, the simulation should involve human driver behavior models. 
On the other hand, if the goal is to evaluate the risk of collision when \iac{ads} is controlling the vehicle, the simulation should include the model of this \ac{ads}.

A straightforward way to compute $\probabilitycond{\collision}{\situationcurrent}$ is to repeat a certain number of simulations with the same $\situationcurrent$ and count the number of simulations that result in the event $\collision$.
If $\numberofsimulations$ denotes the number of simulations and $\numberofcollisions$ is the number of events $\collision$, then $\probabilitycond{\collision}{\situationcurrent}$ could be estimated using
\begin{equation}
	\label{eq:binomial estimation}
	\probabilityestcond{\collision}{\situationcurrent}
	= \frac{\numberofcollisions}{\numberofsimulations}.
\end{equation}

An important choice for estimating $\probabilitycond{\collision}{\situationcurrent}$ is the number of simulations, $\numberofsimulations$.
One approach is to keep increasing $\numberofsimulations$ until there is enough confidence in the estimation of \cref{eq:binomial estimation}.
E.g., the Clopper-Pearson interval \autocite{clopper1934use} or the Wilson score interval \autocite{wilson1927probable} can be used to determine the confidence of the estimation of \cref{eq:binomial estimation}.
A disadvantage of this approach is that only the fact whether the event $\collision$ occurred or not is used while the simulation provides more information. 
Therefore, we provide an alternative approach to estimate $\probabilitycond{\collision}{\situationcurrent}$.

\cstarta For the alternative approach, let us assume that one simulation run provides more information that just the fact that the event $\collision$ occurred or not.
Let $\simulationresult \in \realnumbers^{\dimsimulationresult}$ be a continuous variable representing the result of a simulation run and let $\spacecollision$ denote the set of possible simulation results in which the event $\collision$ occurred. 
Thus, \cenda $\simulationresult \in \spacecollision$ if and only if the simulation results in the event $\collision$.
Therefore, we have
\begin{equation}
	\probabilitycond{\collision}{\situationcurrent}
	= \probabilitycond{\simulationresult \in \spacecollision}{\situationcurrent}
	= \int_{\spacecollision} \densitycond{\simulationresult}{\situationcurrent} \ud \simulationresult.
\end{equation}
Similar as with the estimation of $\density{\situationcurrent, \situationfuture}$ in \cref{sec:estimate future}, we employ \ac{kde} to estimate $\densitycond{\simulationresult}{\situationcurrent}$:
\begin{equation}
	\label{eq:kde simulation result}
	\densityestcond{\simulationresult}{\situationcurrent}
	= \frac{1}{\numberofsimulations} 
	\sum_{\simulationindex=1}^{\numberofsimulations} \kernelfuncnormalized{\simulationbandwidth}{\simulationinstance{\simulationindex} - \simulationresult},
\end{equation}
where $\simulationinstance{\simulationindex}$ denotes the result of the $\simulationindex$-th simulation and $\simulationbandwidth$ denotes an appropriate bandwidth matrix.
The kernel function $\kernelfuncnormalized{\simulationbandwidth}{\cdot}$ is similarly defined as \cref{eq:kernel current future}.
We can now estimate $\probabilitycond{\collision}{\situationcurrent}$ by substituting $\densityestcond{\simulationresult}{\situationcurrent}$ of \cref{eq:kde simulation result} for $\densitycond{\simulationresult}{\situationcurrent}$:
\begin{equation}
	\label{eq:estimate probability of collision}
	\probabilityestcond{\collision}{\situationcurrent}
	= \probabilityestcond{\simulationresult \in \spacecollision}{\situationcurrent}
	= \int_{\spacecollision} \densityestcond{\simulationresult}{\situationcurrent} \ud \simulationresult
	=\frac{1}{\numberofsimulations}
	\sum_{\simulationindex=1}^{\numberofsimulations} \int_{\spacecollision}
	\kernelfuncnormalized{\simulationbandwidth}{\simulationinstance{\simulationindex} - \simulationresult} \ud \simulationresult.
\end{equation}

Similar as with \cref{eq:binomial estimation}, we need to choose the number of simulations $\numberofsimulations$.
Our proposal is to keep increasing $\numberofsimulations$ until the variance of $\probabilityestcond{\simulationresult \in \spacecollision}{\situationcurrent}$ is below a threshold $\simulationthreshold$.
The variance follows from \autocite{nadaraya1964some}:
\begin{equation}
	\variance{\probabilityestcond{\simulationresult \in \spacecollision}{\situationcurrent}}
	= \frac{\probabilitycond{\simulationresult \in \spacecollision}{\situationcurrent}
		\left( 1-\probabilitycond{\simulationresult \in \spacecollision}{\situationcurrent} \right)}{\numberofsimulations}.
\end{equation}
Because $\probabilitycond{\simulationresult \in \spacecollision}{\situationcurrent}$ is unknown, we use the estimated counterpart of \cref{eq:estimate probability of collision}.
Thus, $\numberofsimulations$ is increased until the following condition is met:
\begin{equation}
	\label{eq:condition stop simulations}
	\frac{\probabilityestcond{\simulationresult \in \spacecollision}{\situationcurrent}
		\left( 1-\probabilityestcond{\simulationresult \in \spacecollision}{\situationcurrent} \right)}{\numberofsimulations}
	< \simulationthreshold.
\end{equation}



\subsection{Regression for real-time estimation of $\probabilitycond{\collision}{\situationcurrent}$}
\label{sec:final metric calculation}

To evaluate the risk metric during real-time operation of the ego vehicle, the expression of \cref{eq:estimate probability of collision} is problematic, because it would require multiple $\numberofsimulations$ simulation.
Even if the calculation is accelerated using a technique like importance sampling, it might take too long.
Therefore, we propose to evaluate \cref{eq:estimate probability of collision} only for some fixed $\situationcurrentinstance{\situationindexdesign}$, $\situationindexdesign\in\{1,\ldots,\numberofdesignpoints\}$.
Next, local regression is used to estimate \cref{eq:estimate probability of collision}.
More specifically, we use the \ac{nw} kernel estimator \autocite{wasserman2006nonparametric}:
\begin{equation}
	\label{eq:nadaraya watson}
	\probabilityestcond{\collision}{\situationcurrent}
	\approx \frac{ \sum_{\situationindex=1}^{\numberofdesignpoints}
		\kernelfuncnormalized{\bandwidthnw}{\situationcurrent - \situationcurrentinstance{\situationindexdesign}}
		\probabilityestcond{\collision}{\situationcurrentinstance{\situationindexdesign}}
	}{\sum_{\situationindex=1}^{\numberofdesignpoints}
		\kernelfuncnormalized{\bandwidthnw}{\situationcurrent - \situationcurrentinstance{\situationindexdesign}}}.
\end{equation}
Here, $\probabilityestcond{\collision}{\situationcurrentinstance{\situationindexdesign}}$ is based \cref{eq:estimate probability of collision} and $\kernelfuncnormalized{\bandwidthnw}{\cdot}$ represents the Gaussian kernel given by \cref{eq:kernel current future}.
Two important choices have to be made: The choice of the $\situationcurrentinstance{\situationindexdesign}$, $\situationindexdesign\in\{1,\ldots,\numberofdesignpoints\}$ for which to evaluate \cref{eq:estimate probability of collision} and the choice of the bandwidth matrix $\bandwidthnw$.
We suggest to base the design points $\situationcurrentinstance{\situationindexdesign}$, $\situationindexdesign\in\{1,\ldots,\numberofdesignpoints\}$ on the data that is used to estimate $\densitycond{\situationfuture}{\situationcurrent}$ in \cref{sec:estimate future}, i.e., $\situationcurrentinstance{\situationindex}$, $\situationindex \in \{1,\ldots,\situationnumberof\}$, such that all $\situationcurrentinstance{\situationindex}$ have at least one design point $\situationcurrentinstance{\situationindexdesign}$  nearby.
In other words, $\situationcurrentinstance{\situationindexdesign}$, $\situationindexdesign\in\{1,\ldots,\numberofdesignpoints\}$ is chosen such that
\begin{equation}
	\label{eq:design points distance}
	\min_{\situationindexdesign} 
	\left( \situationcurrentinstance{\situationindex} - \situationcurrentinstance{\situationindexdesign} \right)\transpose
	\weightmatrix 
	\left( \situationcurrentinstance{\situationindex} - \situationcurrentinstance{\situationindexdesign} \right)
	\leq \distancedesignpoints^2,
	\quad \forall \situationindex \in \{1, \ldots, \situationnumberof\},
\end{equation}
where $\weightmatrix$ denotes a weighting matrix and $\distancedesignpoints$ denotes the maximum ``distance''. 
Note that if $\weightmatrix$ is the identity matrix, then \cref{eq:design points distance} calculates the minimum squared Euclidean distance.
\cstarta Choosing $\weightmatrix$ is a trade-off: If $\weightmatrix$ is too large, then too many details are lost in the approximation of \cref{eq:nadaraya watson}.
If $\weightmatrix$ is too small, it takes too long to evaluate \cref{eq:estimate probability of collision} $\numberofdesignpoints$ times, as $\numberofdesignpoints$ increases with decreasing $\weightmatrix$. \cenda
The bandwidth matrix $\bandwidthnw$ might be based on $\weightmatrix$, e.g., $\bandwidthnw=\weightmatrix^{-1}$.
Alternatively, $\bandwidthnw$ might be based on the measurement uncertainty of $\situationcurrent$, where a larger $\bandwidthnw$ applies in case of a larger measurement uncertainty of $\situationcurrent$.


